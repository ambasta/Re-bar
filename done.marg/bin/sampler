#!/usr/bin/env python

'''
This file takes connection csv as provided by linehaul team
and saves it as a json file instead

Expected format of the input CSV data
[
    'Id', 'Origin', 'Destination', 'Cutoff Departure',
    'Cutoff Arrival', 'Vehicle', ['Cost'], ['Active']]

Output JSON Format
[{
   'origin': <unicode>,
   'destination': <unicode>,
   'cutoff_departure': <datetime.datetime>,
   'cutoff_arrival': <datetime.datetime>,
   'cost': <float>,
   'id': <unicode>,
}]
'''

import csv
import click
import datetime
import json
import os
import random

from bunch import Bunch

from done.marg import Marg

from pprint import pprint

from progressbar import Bar, Percentage, ProgressBar


SECONDS_IN_DAY = 24 * 3600
HOURS_DAY = 24


def connection_csv_to_data(source, auto_cost=True, has_inactive=False):
    reader = csv.reader(source)
    data = []

    for row in reader:
        if has_inactive:
            if row[-1] in ['FALSE', '0', False, 0]:
                continue

        data.append(Bunch({
            'id': row[0],
            'origin': row[1].lower(),
            'destination': row[2].lower(),
            'cutoff_departure': row[3],
            'cutoff_arrival': row[4],
            'vehicle': row[5].lower(),
            'cost': row[6] if not auto_cost else 1,
        }))
    source.close()
    return data


def default_json_serializer(obj):
    '''
    Defaullt serializer for python objects
    '''
    if isinstance(obj, datetime.datetime):
        return datetime.datetime.strftime(obj, '%Y-%m-%d %H:%M:%S')
    return obj


def generate_time_slots(intervals=6):
    '''
    Generate time slots to test routes from an origin to destination
    separated by intervals
    '''
    seconds_random = random.randint(0, SECONDS_IN_DAY)
    dt_tom_now = datetime.datetime.now() + datetime.timedelta(days=1)
    dt_tom = datetime.datetime(
        dt_tom_now.year, dt_tom_now.month, dt_tom_now.day, 0, 0, 0) + \
        datetime.timedelta(seconds=seconds_random)
    slots = []
    addendum = 0

    while not addendum or (HOURS_DAY / addendum > 1):
        slots.append(dt_tom + datetime.timedelta(hours=addendum))
        addendum += intervals

    return slots


def pair_dict_from_csv(source):
    '''
    Read pairs csv file and emit dict
    '''
    reader = csv.reader(source)
    pairs = []

    for row in reader:
        pairs.append({
            'source': row[0],
            'destination': row[1],
        })

    return pairs


def populate_pairs(center_list, predefined=[], count=30):
    '''
    Populate 'count' pairs for (origin, destination)
    Optionally take an input of predefined pairs
    '''

    predefined = list(set(predefined))

    gen_count = count - len(predefined)
    center_count = len(center_list)

    while gen_count > 0:
        origin = random.randint(0, center_count - 1)
        destination = random.randint(0, center_count - 1)
        pair = (center_list[origin], center_list[destination])

        if pair not in predefined:
            predefined.append(pair)
            gen_count -= 1

    return predefined[:count]


def load_pairs_from_file(source):
    if os.path.splitext(source.name)[1] == '.json':
        pairs = json.load(source)
    else:
        pairs = pair_dict_from_csv(source)
    source.close()

    response = []
    for pair in pairs:
        response.append((pair['source'], pair['destination']))

    return response


def load_pairs(connections, pairs, center_list, count):
    if pairs:
        pairs = load_pairs_from_file(pairs)
    else:
        pairs = []
    pairs = populate_pairs(center_list, predefined=pairs, count=count)
    return pairs


def populate_city_center_map(city_center_source, center_list):
    reader = csv.reader(city_center_source)

    city_centers = {}

    for city, center in reader:
        city = city.lower().strip()
        center = center.lower().strip()
        if center in center_list:
            if city not in city_centers:
                city_centers[city] = []

            city_centers[city].append(center)
    return city_centers


def populate_zone_matrix(city_centers, zone_matrix_source):
    reader = csv.reader(zone_matrix_source)
    data = [row for row in reader]
    zone_matrix = {}

    for x, row in enumerate(data):
        for y, zone in enumerate(row):
            if x > 0 and y > 0 and x > y:
                zone = zone.lower().strip()
                src = data[0][y].lower().strip()
                dst = data[x][0].lower().strip()
                if zone not in zone_matrix:
                    zone_matrix[zone] = []

                if src in city_centers and dst in city_centers:
                    pair_zone = (src, dst)
                    zone_matrix[zone].append(pair_zone)

    return zone_matrix


def select_pairs(city_centers, zone_matrix, zone, count):
    zm_pairs = zone_matrix[zone]
    zm_count = len(zm_pairs)

    selected_pairs = []

    while len(selected_pairs) < count and len(selected_pairs) < zm_count:
        try:
            pair_idx = random.randint(0, zm_count - 1)
            pair = zm_pairs[pair_idx]
            if pair not in selected_pairs:
                selected_pairs.append(pair)
        except IndexError as error:
            print('Selected: {}'.format(len(selected_pairs)))
            print('Possible: {}: {}'.format(zm_count, zm_pairs))
            print('Accessing: {}'.format(pair_idx))
            raise IndexError(error)

    selected_center_pairs = []
    for origin, destination in selected_pairs:
        origin_center = city_centers[origin][
            random.randint(0, len(city_centers[origin]) - 1)]
        destination_center = city_centers[destination][
            random.randint(0, len(city_centers[destination]) - 1)]
        selected_center_pairs.extend([
            (origin_center, destination_center),
            (destination_center, origin_center)])

    return selected_center_pairs


def select_center_pairs(zone_matrix_source, city_mapping, center_list, count):
    city_centers = populate_city_center_map(city_mapping, center_list)
    zone_matrix = populate_zone_matrix(city_centers, zone_matrix_source)
    pair_samples = {}

    for zone in zone_matrix.keys():
        pair_samples[zone] = select_pairs(
            city_centers, zone_matrix, zone, count)
    return pair_samples


def sec_to_hr(average_time):
    m, s = divmod(average_time, 60)
    h, m = divmod(m, 60)
    d, h = divmod(h, 24)
    return '{} days {}:{}:{}'.format(
        int(d), int(h), int(m), int(s))


def analyze_pairs(connections, interval, pairs, verbose=0):
    all_pair_time = 0
    response = {}
    paths = []
    errors = []

    widgets = ['Averaging Samples', Percentage(), Bar()]
    progress = ProgressBar(widgets=widgets, maxval=len(pairs)).start()

    marg = Marg(connections)

    for pair in pairs:
        progress.update(pairs.index(pair) + 1)
        slots = generate_time_slots(interval)
        average_time = 0
        for slot in slots:
            try:
                shortest_path = marg.shortest_path(pair[0], slot)[pair[1]]
                if verbose > 1:
                    path = ['Shipment arrives at {} at {}'.format(
                        pair[0], slot)]
                    path.extend([(
                        'Shipment leaves {origin} at {departure} and arrives'
                        ' at {destination} at {arrival} taking a time of '
                        '{cost}').format(
                            **path_) for path_ in shortest_path])
                    paths.append(path)
                average_time += shortest_path[-1]['cost']
            except KeyError as error:
                print('{} in marg: {}'.format(
                    pair[0], pair[0] in marg.code_vindex_map))
                print('{} in marg: {}'.format(
                    pair[1], pair[1] in marg.code_vindex_map))
                raise KeyError(error)
        average_time /= len(slots)
        all_pair_time += average_time
        if average_time == float('inf'):
            errors.append(pair)
            continue
        response[pair] = sec_to_hr(average_time)
    print()
    if verbose > 0:
        print('Responses: ')
        pprint(response)
        print('Paths: ')
        for path in paths:
            for step in path:
                print(step)
            print()
        print('Errors: ')
        pprint(errors)
    return all_pair_time / len(pairs)


@click.command(short_help=(
    'Analysis over a user provide [+random] origin-destination sample'))
@click.argument(
    'connection_file', type=click.File('r'))
@click.option(
    '--pairs', default=None, type=click.File('r'),
    help='Location of the pairs file')
@click.option(
    '--zone-matrix', default=None, type=click.File('r'),
    help='Location of the zone matrix file')
@click.option(
    '--city-mapping', default=None, type=click.File('r'),
    help='Location of the city-center mapping file')
@click.option(
    '--count', type=click.IntRange(1, 100), default=30,
    help='# of pairs to sample[1-100]. Defaults to 30.')
@click.option(
    '--auto-cost', type=click.BOOL, default=True,
    help='Assume cost for connections, Defaults to y')
@click.option(
    '--has-inactive', type=click.BOOL, default=False,
    help='Inactive connections specified in data. Defaults to n')
@click.option(
    '--interval', type=click.IntRange(1, 23), default=6,
    help='Sampling interval in hours. Defaults to 6')
@click.option(
    '--verbose', type=click.IntRange(0, 2), default=0,
    help='Verbose sampling')
def main(
        connection_file, pairs, count, auto_cost, has_inactive,
        interval, zone_matrix, city_mapping, verbose):

    connections = connection_csv_to_data(
        connection_file, auto_cost, has_inactive)
    verbose = 2 if count == 1 else verbose

    center_list = [connection.origin for connection in connections]
    center_list.extend([connection.destination for connection in connections])
    center_list = list(set(center_list))

    if zone_matrix and city_mapping:
        zone_pairs = select_center_pairs(
            zone_matrix, city_mapping, center_list, count)
    else:
        zone_pairs = {'': load_pairs(
            connections, pairs, center_list, count)}

    for zone, pairs in zone_pairs.items():
        if zone:
            print('Zone {}'.format(zone.upper()))
        total_tim = analyze_pairs(connections, interval, pairs, verbose)
        if zone:
            print('Average Zone Latency: {}'.format(sec_to_hr(total_tim)))

if __name__ == '__main__':
    main()
